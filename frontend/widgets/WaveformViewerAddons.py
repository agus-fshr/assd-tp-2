# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR
# NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR    -   NO TOCAR  -   NO TOCAR

        self.captureDataButton = Button("Capture Visible Data", on_click=self.captureVisibleData)
        hlayout.addWidget(self.captureDataButton)


        self.label = pg.TextItem()
        self.label.setZValue(20)
        self.proxy = pg.SignalProxy(self.waveformPlot1.scene().sigMouseMoved, rateLimit=60, slot=self.mouseMoved)
        self.waveformPlot1.addItem(self.label)



    @staticmethod
    def eng_format(x, pos=0):
        'The two args are the value and tick position'
        magnitude = 0
        while abs(x) >= 1000:
            magnitude += 1
            x /= 1000.0
        while abs(x) < 1 and magnitude > -3:
            magnitude -= 1
            x *= 1000.0
        # add more suffixes if you need them
        return '{}{}'.format('{:.0f}'.format(x).rstrip('0').rstrip('.'), ['p', 'n', 'u', 'm', '', 'K', 'M', 'G', 'T', 'P'][magnitude+4])
    

    def mouseMoved(self, evt):
        pos = evt[0]  # using signal proxy turns original arguments into a tuple
        if self.waveformPlot1.sceneBoundingRect().contains(pos):
            mousePoint = self.waveformPlot1.vb.mapSceneToView(pos)
            index = int(mousePoint.x())
            if 0 <= index < len(self.x):
                # Set the size of the text
                xstr = self.eng_format(mousePoint.x())
                ystr = self.eng_format(mousePoint.y())
                self.label.setText(f"x={xstr}, y={ystr}")
                self.label.setAnchor((1, 0))

                # get the position of upper right corner of the visible area
                x = self.waveformPlot1.vb.viewRect().right()
                y = self.waveformPlot1.vb.viewRect().top()

                # calculate a small offset
                x_offset = self.waveformPlot1.viewRect().width() * 0.05
                y_offset = self.waveformPlot1.viewRect().height() * 0.2

                # set the position of the text
                self.label.setPos(x - x_offset, y + y_offset)

                
    def captureVisibleData(self):
        minX, maxX = self.region.getRegion()
        x = np.array(self.x)
        y = np.array(self.y)
        mask = (x >= minX) & (x <= maxX)
        x = x[mask]
        y = y[mask]

        event = {
            "type": "captureVisibleData",
            "x": x,
            "y": y
        }
        if self.onEvent is not None:
            self.onEvent(event)



        self.waveformPlot1.addItem(self.label)




def waveformViewerEvent(self, event):
        if event["type"] == "captureVisibleData":
            x = event["x"]
            y = event["y"]

            dx_mean = 0
            c = 0
            for i in range(1, len(x)):
                dx_mean += x[i] - x[i-1]
                c += 1
            dx_mean /= c

            print(f"f_mean: {1/dx_mean}")

            options = QFileDialog.Options()
            options |= QFileDialog.DontUseNativeDialog
            default_filename = "data_out.csv"
            filename, _ = QFileDialog.getSaveFileName(self, "Save as TXT", default_filename, "Text Files (*.txt)", options=options)
            if filename:
                # save as TXT
                with open(filename, mode='w') as file:
                    file.write("RIR_2 = np.array([\n")
                    for i in range(len(y)):
                        file.write(f"{y[i]:.4f},")
                    file.write("])\n")




    def onFFT(self, f, x):
        # search for peaks
        f_50_hz_distance = int(80 / (f[1] - f[0]))
        peaks = signal.find_peaks(x, height=0.0001, distance=f_50_hz_distance)
        peaks_f = f[peaks[0]]
        peaks_x = x[peaks[0]]
        print(f"size: {len(x)}, max: {max(x)}, min: {min(x)} 50_Hz_dist: {f_50_hz_distance} peaks: {len(peaks_f)}")
        
        # Order peaks by amplitude (from highest to lowest amplitude)
        peaks_f = peaks_f[np.argsort(peaks_x)[::-1]]
        peaks_x = peaks_x[np.argsort(peaks_x)[::-1]]

        print("Peaks:")
        for pf, px in zip(peaks_f, peaks_x):
            print(f"\t{pf:.2f} Hz: {px:.5f}")

        self.plotWidget.scatter(peaks_f, peaks_x)
















import numpy as np

t = np.linspace(0, 12, 50000)

x = np.sin(2 * np.pi * t / 5)

envelope = -1*x*np.log10(t)*(1 - np.tanh(t-5)) + 0.5 + np.exp(-50*(t-10)**2)
signal = np.sin(2 * np.pi * 20 * t) * envelope



def dynamic_volume_adjust(input_wave, segment_size=500, threshold=1.0):
    # Calculate the number of segments
    num_segments = len(input_wave) // segment_size

    # Initialize output wave
    output_wave = np.zeros_like(input_wave)

    # Initialize the volume adjustment factors
    volume_adjustment_factors = np.ones(num_segments + 2)

    # First step: calculate the volume adjustment factors
    for i in range(num_segments):
        # Extract the current segment and the next segment
        current_segment = input_wave[i*segment_size:(i+1)*segment_size]
        next_segment = input_wave[(i+1)*segment_size:(i+2)*segment_size] if i+1 < num_segments else np.array([])

        # Calculate the maximum absolute amplitude of the current segment and the next segment
        max_amplitude_current = np.max(np.abs(current_segment))
        max_amplitude_next = np.max(np.abs(next_segment)) if next_segment.size else 0

        # If the maximum amplitude exceeds the threshold
        if max_amplitude_current > threshold or max_amplitude_next > threshold:
            # Calculate the volume adjustment factor
            volume_adjustment_factors[i+1] = threshold / max(max_amplitude_current, max_amplitude_next)

    # Second step: apply the volume adjustment factors
    for i in range(num_segments):
        # Extract the current segment
        segment = input_wave[i*segment_size:(i+1)*segment_size]

        # Calculate the volume adjustment ramp
        volume_adjustment_ramp = np.linspace(volume_adjustment_factors[i], volume_adjustment_factors[i+1], segment_size)

        # Apply the volume adjustment ramp to the segment
        output_wave[i*segment_size:(i+1)*segment_size] = segment * volume_adjustment_ramp

    # Process the remaining samples in the input wave, if any
    if len(input_wave) % segment_size != 0:
        segment = input_wave[num_segments*segment_size:]
        volume_adjustment_ramp = np.linspace(volume_adjustment_factors[-2], volume_adjustment_factors[-1], len(segment))
        output_wave[num_segments*segment_size:] = segment * volume_adjustment_ramp

    return output_wave, volume_adjustment_factors


# newSignal1 = process_mix(signal, 500)
newSignal2, volumeFactors = dynamic_volume_adjust(signal, segment_size=250, threshold=1.0)

volAxis = np.linspace(0, 12, len(volumeFactors))

import matplotlib.pyplot as plt
ax1 = plt

ax1.plot(t, envelope, label='Original Envelope', color='blue')
ax1.axhline(y=1, color='black', linestyle='--', lw=1.5, label='Threshold')
ax1.plot(t, newSignal2, label='New Signal', color='green', lw=0.7)
ax1.plot(volAxis, volumeFactors, label='Volume Factors', color='red', lw=0.7, marker='o', markersize=5)
ax1.grid()
ax1.legend()
plt.tight_layout()
plt.show()